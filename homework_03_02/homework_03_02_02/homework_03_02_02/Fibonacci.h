/* Fibonacci.h */

/* 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377,
 * 610, 987, 1597, 2584, 4181, 6765, 10946, 17711
 */

#ifndef FIBONACCI_H
#define FIBONACCI_H

namespace seq
{
    struct Fibonacci
    {
        static size_t iterative_method(size_t num);

        /*
        * ¬џ„»—Ћ»“≈Ћ№Ќјя ¬–≈ћ≈ЌЌјя —Ћќ∆Ќќ—“№
        * ѕо аналогии оценки сложности алгоритма нахождени€ числа ‘ибоначии
        * итерационным методом проведем анализ сложности рекурсивого метода.
        * ѕосчитаем количество циклов рекурсии (количество окончаний ветвей)
        * дл€ нахождени€ n-го числа ‘ибоначчи.
        * ѕолученный р€д количества циклов не что иное как р€д чисел ‘ибоначчи с
        * сдвигом влево на один элемент, который можно описать экспонентой e^0.4839*x.
        * ћожно сказать, что после определени€ 10-го числа алгоритмическа€ сложность
        * больше чем O(n^2) и меньше O(2^n)
        */
        /*
         * ¬џ„»—Ћ»“≈Ћ№Ќјя ≈ћ ќ—“Ќјя —Ћќ∆Ќќ—“№
         * ≈сли не учитывать переполнение стека,то выделение пам€ти зависит от количества
         * вход€щих данных.
         * ¬џ„»—Ћ»“≈Ћ№Ќјя ≈ћ ќ—“Ќјя —Ћќ∆Ќќ—“№ - O(1)
        */
        static size_t recursive_method(size_t num);

        /*
        * ¬џ„»—Ћ»“≈Ћ№Ќјя ¬–≈ћ≈ЌЌјя —Ћќ∆Ќќ—“№
        * »спользование метода мемоизации позволило исключить все повторные вычислени€ значений.
        * ¬ данном случае операцией определ€ющей алгоритмическую сложность €вл€етс€ push_back(...),
        * дл€ которой сложность - O(n).
        */
        /*
         * ¬џ„»—Ћ»“≈Ћ№Ќјя ≈ћ ќ—“Ќјя —Ћќ∆Ќќ—“№
         * ¬ыделение пам€ти зависит от количества вход€щих данных.
         * ¬џ„»—Ћ»“≈Ћ№Ќјя ≈ћ ќ—“Ќјя —Ћќ∆Ќќ—“№ - O(n)
        */
        static size_t recursive_memo_method(size_t num);
    };
};
#endif /* FIBONACCI_H */